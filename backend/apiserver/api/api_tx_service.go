/*
 * cross-chain-hackathon api
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package api

import (
	"encoding/base64"
	"encoding/binary"
	"log"
	"strconv"

	"github.com/datachainlab/cross-chain-hackathon/backend/apiserver/rdb"
	"github.com/datachainlab/cross/x/ibc/contract/types"
)

// TxApiService is a service that implents the logic for the TxApiServicer
// This service should implement the business logic for every endpoint for the TxApi API.
// Include any external packages or services that will be required by this service.
type TxApiService struct {
	config Config
}

// NewTxApiService creates a default api service
func NewTxApiService(config Config) TxApiServicer {
	return &TxApiService{config}
}

// GetDividend - get a CrossTx to be signed
func (s *TxApiService) GetTxDividend(estateId string, perShare int64) (interface{}, error) {
	tokenId, err := stringToUint64(estateId)
	if err != nil {
		log.Println(err)
		return nil, err
	}

	db, err := rdb.InitDB()
	if err != nil {
		log.Println(err)
		return nil, ErrorFailedDBConnect
	}
	q := `SELECT id FROM user`
	var addrs []string
	if err := db.Select(&addrs, q); err != nil {
		log.Println(err)
		return nil, ErrorFailedDBGet
	}
	q = `SELECT issuedBy FROM estate WHERE tokenId = ?`
	var issuer string
	if err := db.Get(&issuer, q, estateId); err != nil {
		log.Println(err)
		return nil, ErrorFailedDBGet
	}

	cross := &Cross{}

	/* build a cross tx */
	indexResult, err := cross.SimulateContractCall(
		issuer,
		genDividendIndexOfCallInfo(s.config, tokenId),
		s.config.Node[KEY_SECURITY],
	)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	index := binary.BigEndian.Uint64(indexResult.Result.ReturnValue)
	pay, err := cross.SimulateContractCall(
		issuer,
		genPayDividendCallInfo(s.config, tokenId, index),
		s.config.Node[KEY_SECURITY],
	)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	ccrs := []ContractCallResult{*pay}
	cis := []ChannelInfo{s.config.Path[KEY_CO_SECURITY]}

	cumDividend := uint64(0)
	for _, addr := range addrs {
		dividendResult, err := cross.SimulateContractCall(
			issuer,
			genDividendOfCallInfo(s.config, addr, tokenId),
			s.config.Node[KEY_SECURITY],
		)
		if err != nil {
			log.Println(err)
			return nil, err
		}
		dividend := binary.BigEndian.Uint64(dividendResult.Result.ReturnValue)
		log.Printf("dividend of %s: %d", addr, dividend)
		if dividend == 0 {
			continue
		}
		transfer, err := cross.SimulateContractCall(
			issuer,
			genCoinTransferCallInfo(s.config, addr, dividend),
			s.config.Node[KEY_COIN],
		)
		if err := correctTransferOpValue(cumDividend, transfer); err != nil {
			log.Println(err)
			return nil, err
		}
		if err != nil {
			log.Println(err)
			return nil, err
		}
		ccrs = append(ccrs, *transfer)
		cis = append(cis, s.config.Path[KEY_CO_COIN])

		// for demo.
		// for correcting op value
		cumDividend += dividend
	}
	crossTx, err := cross.GenerateMsgInitiate(
		issuer,
		cis,
		ccrs,
		s.config.Node[KEY_COORDINATOR],
	)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	return &crossTx, nil
}

func getIssuerBalance(ccr ContractCallResult) (uint64, error) {
	b, err := base64StrToUint64(ccr.Result.OPs[0].Value.V)
	if err != nil {
		return 0, err
	}
	return b, err
}

// GetTxTradeRequest - get a CrossTx to be signed
func (s *TxApiService) GetTxTradeRequest(tradeId int64, from string) (interface{}, error) {
	// first, get TradeRequest info from db.
	db, err := rdb.InitDB()
	if err != nil {
		log.Println(err)
		return nil, ErrorFailedDBConnect
	}
	t := Trade{}
	q := `SELECT id, estateId, unitPrice, amount, seller, status FROM trade WHERE id = ?`
	row := db.QueryRow(q, tradeId)
	if err := row.Scan(&t.Id, &t.EstateId, &t.UnitPrice, &t.Amount, &t.Seller, &t.Status); err != nil {
		log.Println(err)
		return nil, ErrorFailedDBGet
	}
	if t.Status != TRADE_OPENED {
		log.Println(err)
		return nil, ErrorWrongStatus
	}

	cross := NewCross()
	simCoin, err := cross.SimulateContractCall(
		from,
		genCoinTransferCallInfo(s.config, t.Seller, uint64(t.UnitPrice*t.Amount)),
		s.config.Node[KEY_COIN],
	)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	tokenId, err := stringToUint64(t.EstateId)
	if err != nil {
		log.Println(err)
		return nil, err
	}

	simSecurity, err := cross.SimulateContractCall(
		t.Seller,
		genEstateTransferCallInfo(s.config, tokenId, from, uint64(t.Amount)),
		s.config.Node[KEY_SECURITY],
	)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	// sender is the seller
	crossTx, err := cross.GenerateMsgInitiate(
		t.Seller,
		[]ChannelInfo{s.config.Path[KEY_CO_COIN], s.config.Path[KEY_CO_SECURITY]},
		[]ContractCallResult{*simCoin, *simSecurity},
		s.config.Node[KEY_COORDINATOR],
	)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	return &crossTx, nil
}

func genDividendIndexOfCallInfo(c Config, tokenId uint64) types.ContractCallInfo {
	return types.ContractCallInfo{
		c.Contract[KEY_SECURITY].Id,
		"dividendIndexOf",
		[][]byte{
			uint64ToByte(tokenId),
		},
	}
}

func genCoinTransferCallInfo(c Config, to string, amount uint64) types.ContractCallInfo {
	return types.ContractCallInfo{
		c.Contract[KEY_COIN].Id,
		"transfer",
		[][]byte{
			[]byte(to),
			uint64ToByte(amount),
		},
	}
}

func genEstateTransferCallInfo(c Config, tokenId uint64, addr string, amount uint64) types.ContractCallInfo {
	return types.ContractCallInfo{
		c.Contract[KEY_SECURITY].Id,
		"transfer",
		[][]byte{
			uint64ToByte(tokenId),
			[]byte(addr),
			uint64ToByte(amount),
		},
	}
}

func genDividendOfCallInfo(c Config, addr string, tokenId uint64) types.ContractCallInfo {
	return types.ContractCallInfo{
		c.Contract[KEY_SECURITY].Id,
		"dividendOf",
		[][]byte{
			[]byte(addr),
			uint64ToByte(tokenId),
		},
	}
}

func genPayDividendCallInfo(c Config, tokenId, index uint64) types.ContractCallInfo {
	return types.ContractCallInfo{
		c.Contract[KEY_SECURITY].Id,
		"payDividend",
		[][]byte{
			uint64ToByte(tokenId),
			uint64ToByte(index),
		},
	}
}

// HACK for demo only
func correctTransferOpValue(cumDividend uint64, ccr *ContractCallResult) error {
	ccrB, err := base64StrToUint64(ccr.Result.OPs[0].Value.V)
	if err != nil {
		return err
	}
	corrected := uint64ToBase64(ccrB - cumDividend)
	ccr.Result.OPs[0].Value.V = corrected
	return nil
}

func base64StrToUint64(str string) (uint64, error) {
	strB, err := base64.StdEncoding.DecodeString(str)
	if err != nil {
		return 0, err
	}
	return binary.BigEndian.Uint64(strB), nil
}

func uint64ToBase64(val uint64) string {
	b := make([]byte, 8)
	binary.BigEndian.PutUint64(b, val)
	return base64.StdEncoding.EncodeToString(b)
}

// HACK
// this needs for the type mismatch between contract tokenId(uint64) and model schema(string)
func stringToUint64(str string) (uint64, error) {
	return strconv.ParseUint(str, 10, 64)
}

func uint64ToByte(v uint64) []byte {
	var bz [8]byte
	binary.BigEndian.PutUint64(bz[:], v)
	return bz[:]
}
